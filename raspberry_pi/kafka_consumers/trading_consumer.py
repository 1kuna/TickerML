#!/usr/bin/env python3
"""
Kafka Consumer for Trading Decisions
Consumes features and news sentiment to make trading decisions
"""

import json
import logging
import asyncio
from typing import Dict, Any, Optional
from datetime import datetime, timedelta
import yaml
from kafka import KafkaConsumer, KafkaProducer
from kafka.errors import KafkaError
import coloredlogs
import numpy as np

# Local imports
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
from raspberry_pi.paper_trader import PaperTrader
from raspberry_pi.risk_manager import RiskManager
from raspberry_pi.infer import load_model, make_prediction

class TradingConsumer:
    """Consumes features and makes trading decisions"""
    
    def __init__(self, config_path: str = 'config/kafka_config.yaml'):
        """Initialize Kafka consumer for trading decisions"""
        self.logger = logging.getLogger(self.__class__.__name__)
        coloredlogs.install(level='INFO', logger=self.logger)
        
        # Load configuration
        with open(config_path, 'r') as f:
            kafka_config = yaml.safe_load(f)
            
        self.config = kafka_config['kafka']
        
        # Initialize consumer for features
        self.consumer = KafkaConsumer(
            'crypto-features',  # Features generated by feature_consumer
            self.config['topics']['news'] + '-sentiment',  # Sentiment aggregates
            bootstrap_servers=self.config['brokers'],
            value_deserializer=lambda m: json.loads(m.decode('utf-8')),
            key_deserializer=lambda m: m.decode('utf-8') if m else None,
            auto_offset_reset='latest',
            enable_auto_commit=True,
            group_id='trading-decisions'
        )
        
        # Initialize producer for trading signals
        self.producer = KafkaProducer(
            bootstrap_servers=self.config['brokers'],
            value_serializer=lambda v: json.dumps(v).encode('utf-8'),
            key_serializer=lambda k: k.encode('utf-8') if k else None,
            compression_type='gzip'
        )
        
        # Initialize trading components
        self.paper_trader = PaperTrader()
        self.risk_manager = RiskManager()
        
        # Load model for inference
        self.model = None
        self.model_loaded = False
        self._load_trading_model()
        
        # Feature and sentiment buffers
        self.latest_features: Dict[str, Dict] = {}
        self.latest_sentiment: Optional[Dict] = None
        
        # Trading state
        self.last_trading_decision: Dict[str, datetime] = {}
        self.trading_interval = 60  # seconds between trading decisions
        
        self.logger.info("Initialized TradingConsumer")
    
    def _load_trading_model(self):
        """Load the trading model"""
        try:
            self.model = load_model()
            if self.model:
                self.model_loaded = True
                self.logger.info("Trading model loaded successfully")
            else:
                self.logger.warning("No trading model available, using rule-based system")
        except Exception as e:
            self.logger.error(f"Error loading model: {e}")
            self.model_loaded = False
    
    def process_features(self, message: Dict[str, Any]):
        """Process incoming features"""
        try:
            symbol = message.get('symbol')
            if not symbol:
                return
            
            self.latest_features[symbol] = message
            self.logger.debug(f"Updated features for {symbol}")
            
            # Check if we should make a trading decision
            if self.should_make_trading_decision(symbol):
                asyncio.create_task(self.make_trading_decision(symbol))
                
        except Exception as e:
            self.logger.error(f"Error processing features: {e}")
    
    def process_sentiment(self, message: Dict[str, Any]):
        """Process incoming sentiment data"""
        try:
            self.latest_sentiment = message
            self.logger.debug(f"Updated sentiment: {message['sentiment']['average']:.3f}")
            
        except Exception as e:
            self.logger.error(f"Error processing sentiment: {e}")
    
    def should_make_trading_decision(self, symbol: str) -> bool:
        """Check if we should make a trading decision for symbol"""
        last_decision = self.last_trading_decision.get(symbol)
        if not last_decision:
            return True
        
        time_since_decision = (datetime.utcnow() - last_decision).total_seconds()
        return time_since_decision >= self.trading_interval
    
    async def make_trading_decision(self, symbol: str):
        """Make a trading decision for symbol"""
        try:
            features = self.latest_features.get(symbol)
            if not features:
                return
            
            # Get current portfolio state
            portfolio = self.paper_trader.get_portfolio_state()
            
            # Check risk limits
            risk_assessment = self.risk_manager.assess_trade_risk(
                symbol=symbol,
                current_portfolio=portfolio,
                proposed_action='evaluate'
            )
            
            if not risk_assessment['can_trade']:
                self.logger.info(f"Risk limits prevent trading {symbol}: {risk_assessment['reason']}")
                return
            
            # Generate trading signal
            signal = await self._generate_trading_signal(symbol, features)
            
            if signal['action'] != 'hold':
                # Execute trade
                trade_result = await self._execute_trade(symbol, signal)
                
                # Send trading signal to Kafka
                await self._send_trading_signal(symbol, signal, trade_result)
                
                self.logger.info(f"Trading decision for {symbol}: {signal['action']} "
                               f"confidence={signal['confidence']:.3f}")
            
            self.last_trading_decision[symbol] = datetime.utcnow()
            
        except Exception as e:
            self.logger.error(f"Error making trading decision for {symbol}: {e}")
    
    async def _generate_trading_signal(self, symbol: str, features: Dict[str, Any]) -> Dict[str, Any]:
        """Generate trading signal using model or rules"""
        
        # Base signal structure
        signal = {
            'timestamp': datetime.utcnow().isoformat(),
            'symbol': symbol,
            'action': 'hold',
            'confidence': 0.0,
            'position_size': 0.0,
            'reason': 'no_signal',
            'features_used': list(features.keys()),
            'method': 'rule_based'
        }
        
        try:
            if self.model_loaded and self.model:
                # Use ML model for prediction
                signal.update(await self._ml_prediction(symbol, features))
                signal['method'] = 'ml_model'
            else:
                # Use rule-based system
                signal.update(self._rule_based_prediction(symbol, features))
                signal['method'] = 'rule_based'
                
        except Exception as e:
            self.logger.error(f"Error generating signal: {e}")
            # Fallback to safe hold
            signal['reason'] = f'error: {str(e)}'
        
        return signal
    
    async def _ml_prediction(self, symbol: str, features: Dict[str, Any]) -> Dict[str, Any]:
        """Generate prediction using ML model"""
        try:
            # Prepare feature vector
            feature_vector = self._prepare_features_for_model(features)
            
            # Make prediction
            prediction = make_prediction(self.model, feature_vector)
            
            # Convert prediction to trading signal
            if isinstance(prediction, dict):
                action_probs = prediction.get('action_probs', [0.33, 0.33, 0.34])  # [buy, sell, hold]
                confidence = max(action_probs)
                action_idx = np.argmax(action_probs)
                actions = ['buy', 'sell', 'hold']
                action = actions[action_idx]
                
                position_size = prediction.get('position_size', 0.02)  # 2% default
                
            else:
                # Simple prediction value
                if prediction > 0.6:
                    action = 'buy'
                    confidence = prediction
                elif prediction < 0.4:
                    action = 'sell'
                    confidence = 1 - prediction
                else:
                    action = 'hold'
                    confidence = 0.5
                
                position_size = min(0.05, abs(prediction - 0.5) * 0.1)  # Max 5%
            
            # Apply sentiment adjustment
            if self.latest_sentiment:
                sentiment_score = self.latest_sentiment['sentiment']['average']
                confidence *= (1 + sentiment_score * 0.1)  # Â±10% adjustment
                
                # Reduce position size in high uncertainty
                sentiment_std = self.latest_sentiment['sentiment']['std']
                if sentiment_std > 0.5:
                    position_size *= 0.5
            
            return {
                'action': action,
                'confidence': min(confidence, 1.0),
                'position_size': position_size,
                'reason': 'ml_prediction'
            }
            
        except Exception as e:
            self.logger.error(f"ML prediction error: {e}")
            return {'reason': f'ml_error: {str(e)}'}
    
    def _rule_based_prediction(self, symbol: str, features: Dict[str, Any]) -> Dict[str, Any]:
        """Generate prediction using rule-based system"""
        
        # Extract key features
        imbalance = features.get('imbalance_current', 0)
        imbalance_trend = features.get('imbalance_trend', 0)
        flow_imbalance = features.get('trade_flow_imbalance', 0)
        price_vs_vwap = features.get('price_vs_vwap', 0)
        spread = features.get('spread_current', 0)
        volatility = features.get('mid_price_volatility', 0)
        
        # Initialize signal
        buy_score = 0
        sell_score = 0
        reasons = []
        
        # Order book imbalance signals (strongest short-term predictor)
        if imbalance > 0.3:
            buy_score += 0.4
            reasons.append('strong_bid_imbalance')
        elif imbalance < -0.3:
            sell_score += 0.4
            reasons.append('strong_ask_imbalance')
        
        # Imbalance trend
        if imbalance_trend > 0.01:
            buy_score += 0.2
            reasons.append('improving_bid_pressure')
        elif imbalance_trend < -0.01:
            sell_score += 0.2
            reasons.append('improving_ask_pressure')
        
        # Trade flow imbalance
        if flow_imbalance > 0.2:
            buy_score += 0.3
            reasons.append('strong_buy_flow')
        elif flow_imbalance < -0.2:
            sell_score += 0.3
            reasons.append('strong_sell_flow')
        
        # Price vs VWAP (mean reversion)
        if price_vs_vwap < -0.002:  # 0.2% below VWAP
            buy_score += 0.25
            reasons.append('below_vwap')
        elif price_vs_vwap > 0.002:  # 0.2% above VWAP
            sell_score += 0.25
            reasons.append('above_vwap')
        
        # Sentiment overlay
        if self.latest_sentiment:
            sentiment_score = self.latest_sentiment['sentiment']['average']
            if sentiment_score > 0.3:
                buy_score += 0.1
                reasons.append('positive_sentiment')
            elif sentiment_score < -0.3:
                sell_score += 0.1
                reasons.append('negative_sentiment')
        
        # Risk adjustments
        confidence_penalty = 0
        if spread > 0.001:  # Wide spread
            confidence_penalty += 0.2
            reasons.append('wide_spread_penalty')
        
        if volatility > 0.02:  # High volatility
            confidence_penalty += 0.15
            reasons.append('high_volatility_penalty')
        
        # Make decision
        if buy_score > sell_score and buy_score > 0.5:
            action = 'buy'
            confidence = min(buy_score - confidence_penalty, 1.0)
            position_size = min(0.05, confidence * 0.1)  # Max 5%, scaled by confidence
        elif sell_score > buy_score and sell_score > 0.5:
            action = 'sell'
            confidence = min(sell_score - confidence_penalty, 1.0)
            position_size = min(0.05, confidence * 0.1)
        else:
            action = 'hold'
            confidence = 0.3
            position_size = 0.0
            reasons.append('insufficient_signal')
        
        return {
            'action': action,
            'confidence': max(confidence, 0.0),
            'position_size': position_size,
            'reason': ', '.join(reasons),
            'scores': {'buy': buy_score, 'sell': sell_score}
        }
    
    def _prepare_features_for_model(self, features: Dict[str, Any]) -> np.ndarray:
        """Prepare features for model input"""
        # Define expected feature order
        feature_names = [
            'imbalance_current', 'imbalance_trend', 'trade_flow_imbalance',
            'price_vs_vwap', 'spread_current', 'mid_price_volatility',
            'buy_volume_ratio', 'market_impact_mean', 'liquidity_score'
        ]
        
        # Extract features in order
        feature_vector = []
        for name in feature_names:
            value = features.get(name, 0.0)
            # Handle NaN values
            if np.isnan(value) or np.isinf(value):
                value = 0.0
            feature_vector.append(value)
        
        return np.array(feature_vector, dtype=np.float32)
    
    async def _execute_trade(self, symbol: str, signal: Dict[str, Any]) -> Dict[str, Any]:
        """Execute trade through paper trader"""
        try:
            if signal['action'] == 'buy':
                result = self.paper_trader.buy(
                    symbol=symbol,
                    amount_usd=signal['position_size'] * self.paper_trader.portfolio['cash_balance']
                )
            elif signal['action'] == 'sell':
                result = self.paper_trader.sell(
                    symbol=symbol,
                    percentage=signal['position_size']
                )
            else:
                result = {'success': True, 'action': 'hold', 'message': 'No action taken'}
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error executing trade: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _send_trading_signal(self, symbol: str, signal: Dict[str, Any], trade_result: Dict[str, Any]):
        """Send trading signal to Kafka"""
        try:
            message = {
                **signal,
                'trade_result': trade_result,
                'portfolio_state': self.paper_trader.get_portfolio_state()
            }
            
            self.producer.send(
                self.config['topics']['signals'],
                key=symbol,
                value=message
            )
            
        except Exception as e:
            self.logger.error(f"Error sending trading signal: {e}")
    
    async def run(self):
        """Main consumer loop"""
        self.logger.info("Starting trading consumer...")
        
        try:
            while True:
                # Poll messages
                messages = self.consumer.poll(timeout_ms=1000)
                
                for topic_partition, msgs in messages.items():
                    topic = topic_partition.topic
                    
                    for message in msgs:
                        if topic == 'crypto-features':
                            self.process_features(message.value)
                        elif 'sentiment' in topic:
                            self.process_sentiment(message.value)
                
                # Small sleep to prevent busy waiting
                await asyncio.sleep(0.1)
                
        except KeyboardInterrupt:
            self.logger.info("Shutting down trading consumer...")
        except Exception as e:
            self.logger.error(f"Consumer error: {e}")
        finally:
            self.consumer.close()
            self.producer.close()
            self.logger.info("Trading consumer stopped")
    
    def health_check(self) -> Dict[str, Any]:
        """Check consumer health"""
        return {
            'consumer_active': True,
            'model_loaded': self.model_loaded,
            'symbols_tracked': len(self.latest_features),
            'sentiment_available': self.latest_sentiment is not None,
            'last_decisions': {
                k: v.isoformat() for k, v in self.last_trading_decision.items()
            },
            'portfolio_value': self.paper_trader.get_portfolio_value()
        }


def main():
    """Main entry point"""
    consumer = TradingConsumer()
    asyncio.run(consumer.run())


if __name__ == "__main__":
    main()